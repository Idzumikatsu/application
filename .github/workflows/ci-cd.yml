name: CRM System CI/CD

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]
  workflow_dispatch:

env:
  JAVA_VERSION: '17'
  NODE_VERSION: '20'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ secrets.IMAGE_NAME }}
  POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
  POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
  POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
  DATABASE_URL: ${{ secrets.DATABASE_URL }}
  DATABASE_USERNAME: ${{ secrets.DATABASE_USERNAME }}
  DATABASE_PASSWORD: ${{ secrets.DATABASE_PASSWORD }}
  JWT_SECRET: ${{ secrets.JWT_SECRET }}
  MAIL_HOST: ${{ secrets.MAIL_HOST }}
  MAIL_PORT: ${{ secrets.MAIL_PORT }}
  MAIL_USERNAME: ${{ secrets.MAIL_USERNAME }}
  MAIL_PASSWORD: ${{ secrets.MAIL_PASSWORD }}
  TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
  TELEGRAM_BOT_USERNAME: ${{ secrets.TELEGRAM_BOT_USERNAME }}
  EMAIL_GATEWAY_BASE_URL: ${{ secrets.EMAIL_GATEWAY_BASE_URL }}
  APP_FRONTEND_URL: ${{ secrets.APP_FRONTEND_URL }}
  SUPPORT_EMAIL: ${{ secrets.SUPPORT_EMAIL }}
  TELEGRAM_BOT_URL: ${{ secrets.TELEGRAM_BOT_URL }}

jobs:
  frontend-tests:
    name: Frontend Tests
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Get npm cache directory
      id: npm-cache-dir
      shell: bash
      run: echo "dir=$(npm config get cache)" >> $GITHUB_OUTPUT

    - name: Setup npm cache
      uses: actions/cache@v4
      id: npm-cache
      with:
        path: ${{ steps.npm-cache-dir.outputs.dir }}
        key: ${{ runner.os }}-node-${{ hashFiles('**/frontend/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node-

    - name: Set up Node.js ${{ env.NODE_VERSION }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}

    - name: Install frontend dependencies
      run: |
        cd frontend
        npm ci

    - name: Install rollup native module for CI environment
      run: |
        cd frontend
        npm install --no-save @rollup/rollup-linux-x64-gnu

    - name: TypeScript check
      run: |
        cd frontend
        npx tsc --noEmit

    - name: Run unit tests
      run: |
        cd frontend
        npm run test:coverage
      env:
        CI: true

    - name: Build frontend
      run: |
        cd frontend
        npm run build

    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: frontend-test-results
        path: frontend/coverage

    - name: Verify frontend build exists
      run: |
        cd frontend
        if [ -d "dist" ]; then
          echo "Frontend build directory exists"
          ls -la dist/
        else
          echo "ERROR: Frontend build directory does not exist!"
          exit 1
        fi

  backend-tests:
    name: Backend Tests
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_DB: ${{ env.POSTGRES_DB }}
          POSTGRES_USER: ${{ env.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ env.POSTGRES_PASSWORD }}
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Cache Maven packages
      uses: actions/cache@v4
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/crm-system/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2

    - name: Install PostgreSQL client
      run: |
        sudo apt-get update
        sudo apt-get install -y postgresql-client

    - name: Wait for PostgreSQL to be ready
      run: |
        echo "Waiting for PostgreSQL to be ready..."
        for i in {1..30}; do
          if pg_isready -h localhost -p 5432 -U ${{ env.POSTGRES_USER }} -d ${{ env.POSTGRES_DB }} >/dev/null 2>&1; then
            echo "PostgreSQL is ready!"
            exit 0
          fi
          echo "Waiting... ($i/30)"
          sleep 2
        done
        echo "PostgreSQL not ready in time"
        exit 1

    - name: Set up JDK ${{ env.JAVA_VERSION }}
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: 'temurin'

    - name: Build and test backend
      env:
        DATABASE_URL: jdbc:postgresql://localhost:5432/${{ env.POSTGRES_DB }}
        DATABASE_USERNAME: ${{ env.POSTGRES_USER }}
        DATABASE_PASSWORD: ${{ env.POSTGRES_PASSWORD }}
      run: |
        cd crm-system
        mvn clean test -Dspring.profiles.active=test -DskipTests=false -Dmaven.test.failure.ignore=true -Djacoco.skip=false

    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: backend-test-results
        path: crm-system/target/surefire-reports/

    - name: Upload coverage report
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: backend-coverage-report
        path: crm-system/target/site/jacoco/

  build-and-push-images:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: [backend-tests, frontend-tests]
    if: github.ref == 'refs/heads/master'
    permissions:
      contents: read
      packages: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata for backend image
      id: meta-backend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/backend

    - name: Build and push backend image
      uses: docker/build-push-action@v5
      with:
        context: ./crm-system
        file: ./crm-system/Dockerfile
        push: true
        tags: ${{ steps.meta-backend.outputs.tags }}
        labels: ${{ steps.meta-backend.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Extract metadata for frontend image
      id: meta-frontend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/frontend

    - name: Build and push frontend image
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        file: ./frontend/Dockerfile
        push: true
        tags: ${{ steps.meta-frontend.outputs.tags }}
        labels: ${{ steps.meta-frontend.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Extract metadata for email-service image
      id: meta-email
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/email-service

    - name: Build and push email-service image
      uses: docker/build-push-action@v5
      with:
        context: ./email-service
        file: ./email-service/Dockerfile
        push: true
        tags: ${{ steps.meta-email.outputs.tags }}
        labels: ${{ steps.meta-email.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Verify email-service image push
      run: |
        IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/email-service:latest"
        if docker manifest inspect $IMAGE >/dev/null 2>&1; then
          echo "‚úÖ email-service pushed successfully"
        else
          echo "‚ùå email-service push failed - check Dockerfile/pom.xml in email-service/"
          ls -la email-service/ || echo "Directory missing!"
          exit 1
        fi

    - name: Extract metadata for telegram-service image
      id: meta-telegram
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/telegram-service

    - name: Build and push telegram-service image
      uses: docker/build-push-action@v5
      with:
        context: ./telegram-service
        file: ./telegram-service/Dockerfile
        push: true
        tags: ${{ steps.meta-telegram.outputs.tags }}
        labels: ${{ steps.meta-telegram.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build-and-push-images
    if: github.ref == 'refs/heads/master'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Check if SSH secrets are available
      run: |
        echo "Checking if SSH secrets are configured..."
        if [ -z "${{ secrets.DEPLOY_SSH_KEY }}" ]; then
          echo "SSH_PRIVATE_KEY is not set"
        else
          echo "SSH_PRIVATE_KEY is configured (length: ${#DEPLOY_SSH_KEY})"
        fi
        
        if [ -z "${{ secrets.DEPLOY_USER }}" ]; then
          echo "PRODUCTION_USER is not set"
        else
          echo "PRODUCTION_USER is configured"
        fi
        
        if [ -z "${{ secrets.DEPLOY_HOST }}" ]; then
          echo "PRODUCTION_HOST is not set"
        else
          echo "PRODUCTION_HOST is configured"
        fi

    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.9.0
      with:
        ssh-private-key: ${{ secrets.DEPLOY_SSH_KEY }}

    - name: Test SSH Connection
      run: |
        echo "Testing SSH connection to production server..."
        if [ -n "${{ secrets.DEPLOY_HOST }}" ] && [ -n "${{ secrets.DEPLOY_USER }}" ]; then
          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} "echo 'SSH connection successful'" || echo "SSH connection failed"
        else
          echo "Skipping SSH test - missing host or user configuration"
        fi

    - name: Deploy with Docker Compose
      run: |
        echo "Starting deployment process..."
        if [ -z "${{ secrets.DEPLOY_HOST }}" ] || [ -z "${{ secrets.DEPLOY_USER }}" ] || [ -z "${{ secrets.DEPLOY_SSH_KEY }}" ]; then
          echo "‚ùå Deployment failed: Missing required secrets"
          echo "Please configure DEPLOY_SSH_KEY, DEPLOY_USER, and DEPLOY_HOST in GitHub Actions secrets"
          exit 1
        fi
        
        ssh -o StrictHostKeyChecking=no ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} <<'EOF'
        echo "‚úÖ Connected to production server"
        cd /opt/application || (echo "‚ùå Failed to change directory" && exit 1)
        echo "üìù Updating environment configuration"
        export POSTGRES_DB='${{ secrets.POSTGRES_DB }}'
        export POSTGRES_USER='${{ secrets.POSTGRES_USER }}'
        export POSTGRES_PASSWORD='${{ secrets.POSTGRES_PASSWORD }}'
        export DATABASE_URL='${{ secrets.DATABASE_URL }}'
        export DATABASE_USERNAME='${{ secrets.DATABASE_USERNAME }}'
        export DATABASE_PASSWORD='${{ secrets.DATABASE_PASSWORD }}'
        export JWT_SECRET='${{ secrets.JWT_SECRET }}'
        export MAIL_HOST='${{ secrets.MAIL_HOST }}'
        export MAIL_PORT='${{ secrets.MAIL_PORT }}'
        export MAIL_USERNAME='${{ secrets.MAIL_USERNAME }}'
        export MAIL_PASSWORD='${{ secrets.MAIL_PASSWORD }}'
        export EMAIL_GATEWAY_BASE_URL='${{ secrets.EMAIL_GATEWAY_BASE_URL }}'
        export APP_FRONTEND_URL='${{ secrets.APP_FRONTEND_URL }}'
        export SUPPORT_EMAIL='${{ secrets.SUPPORT_EMAIL }}'
        export TELEGRAM_BOT_URL='${{ secrets.TELEGRAM_BOT_URL }}'
        export TELEGRAM_BOT_TOKEN='${{ secrets.TELEGRAM_BOT_TOKEN }}'
        export TELEGRAM_BOT_USERNAME='${{ secrets.TELEGRAM_BOT_USERNAME }}'
        export REGISTRY='${{ env.REGISTRY }}'
        export IMAGE_NAME='${{ secrets.IMAGE_NAME }}'
        python3 <<'PY'
import os
from collections import OrderedDict

config = OrderedDict([
    ("POSTGRES_DB", os.environ["POSTGRES_DB"]),
    ("POSTGRES_USER", os.environ["POSTGRES_USER"]),
    ("POSTGRES_PASSWORD", os.environ["POSTGRES_PASSWORD"]),
    ("DATABASE_URL", os.environ["DATABASE_URL"]),
    ("DATABASE_USERNAME", os.environ["DATABASE_USERNAME"]),
    ("DATABASE_PASSWORD", os.environ["DATABASE_PASSWORD"]),
    ("JWT_SECRET", os.environ["JWT_SECRET"]),
    ("JWT_EXPIRATION", "86400"),
    ("PORT", "8080"),
    ("MAIL_HOST", os.environ["MAIL_HOST"]),
    ("MAIL_PORT", os.environ["MAIL_PORT"]),
    ("EMAIL_USERNAME", os.environ["MAIL_USERNAME"]),
    ("MAIL_PASSWORD", os.environ["MAIL_PASSWORD"]),
    ("MAIL_PROTOCOL", "smtps"),
    ("MAIL_SMTP_AUTH", "true"),
    ("MAIL_SMTP_STARTTLS_ENABLE", "false"),
    ("MAIL_SMTP_SSL_ENABLE", "true"),
    ("MAIL_SMTP_CONNECTIONTIMEOUT", "5000"),
    ("MAIL_SMTP_TIMEOUT", "5000"),
    ("MAIL_SMTP_WRITETIMEOUT", "5000"),
    ("EMAIL_GATEWAY_BASE_URL", os.environ["EMAIL_GATEWAY_BASE_URL"]),
    ("APP_FRONTEND_URL", os.environ["APP_FRONTEND_URL"]),
    ("SUPPORT_EMAIL", os.environ["SUPPORT_EMAIL"]),
    ("TELEGRAM_BOT_URL", os.environ["TELEGRAM_BOT_URL"]),
    ("TELEGRAM_BOT_TOKEN", os.environ["TELEGRAM_BOT_TOKEN"]),
    ("TELEGRAM_BOT_USERNAME", os.environ["TELEGRAM_BOT_USERNAME"]),
    ("POSTGRES_HEALTHCHECK_USER", os.environ["POSTGRES_USER"]),
    ("POSTGRES_HEALTHCHECK_PASSWORD", os.environ["POSTGRES_PASSWORD"]),
    ("POSTGRES_HEALTHCHECK_DB", os.environ["POSTGRES_DB"]),
    ("REGISTRY", os.environ["REGISTRY"]),
    ("IMAGE_NAME", os.environ["IMAGE_NAME"]),
    ("DEPLOY_PATH", "/opt/application"),
    ("SPRING_SERVLET_MULTIPART_MAX_FILE_SIZE", "10MB"),
    ("SPRING_SERVLET_MULTIPART_MAX_REQUEST_SIZE", "10MB"),
    ("SERVER_SERVLET_SESSION_TIMEOUT", "30m"),
    ("SPRING_SESSION_STORE_TYPE", "jdbc"),
    ("SPRING_SESSION_JDBC_INITIALIZE_SCHEMA", "always"),
    ("SPRING_MAIN_LAZY_INITIALIZATION", "true"),
    ("LOGGING_LEVEL_COM_CRM_SYSTEM", "INFO"),
    ("LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_SECURITY", "INFO"),
    ("LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_WEB", "INFO"),
    ("HEALTH_CHECK_TIMEOUT", "30"),
    ("HEALTH_CHECK_INTERVAL", "10"),
    ("SPRING_BOOT_HEALTHCHECK_ENABLED", "true"),
    ("SPRING_BOOT_HEALTHCHECK_PATH", "/actuator/health"),
    ("SPRING_BOOT_HEALTHCHECK_TIMEOUT", "30s"),
    ("SPRING_BOOT_HEALTHCHECK_INTERVAL", "10s"),
    ("BACKUP_RETENTION_DAYS", "7"),
])

with open(".env", "w", encoding="utf-8") as f:
    for key, value in config.items():
        f.write(f"{key}={value}\n")
PY
        chmod 600 .env
        echo "üîç Pulling latest code from repository"
        git pull origin master || (echo "‚ùå Failed to pull latest code" && exit 1)
        
        # Authenticate with GitHub Container Registry
        echo "üîê Authenticating with GitHub Container Registry"
        echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
        
        echo "üîç Pulling latest Docker images"
        # Try to pull images, but continue even if they don't exist yet
        docker compose pull || echo "‚ö†Ô∏è  Some images could not be pulled (may not exist yet)"
        echo "üöÄ Starting containers"
        # Use --force-recreate to ensure we start fresh containers
        docker compose up -d --remove-orphans --force-recreate || (echo "‚ùå Failed to start containers" && exit 1)
        echo "‚è≥ Waiting for containers to start"
        sleep 120
        echo "üìã Checking container status"
        docker compose ps
        echo "üìã Getting container logs"
        docker compose logs --tail=20
        # Basic health check
        if docker compose exec backend curl -f http://localhost:8084/actuator/health >/dev/null 2>&1; then
          echo '‚úÖ Backend healthy'
        else
          echo '‚ö†Ô∏è  Backend health check failed (may still be starting up)'
          docker compose logs backend --tail=30
        fi
        EOF
